// by critor, warnings fixed by parrotgeek1
//
// 512K : TI-73                     0C-15   0A   10   160Kio   163840
// 512K : TI-83 Plus               0C-15   0A   10   160Kio   163840
// 1024K : TI-84 Plus               0C-29   1E   30   480Kio   491520
// 1024K : TI-82 Advanced            0C-29   1E   30   480Kio
// 2048K : TI-83 Plus Silver Edition   0C-69   5E   94   1504Kio   1540Ko
// 2048K : TI-84 Plus Silver Edition   0C-69   5E   94   1504Kio   1540Ko
// 2048K : TI-84 Plus T               0C-69   5E   94   1504Kio
// 4096K : TI-84 Plus C Silver Edition   0C-E3   D8   216   3456Kio   3539Ko

#include <stdio.h>
#include <stdint.h>   
#include <stdlib.h>   
#include <string.h>  
#define TYPE_SIZE 9

unsigned char getbyte(char** p) {
   int byte = *(*p);
   *p=(*p)+1;
   return byte;
}

unsigned short gethalfword(char** p) {
   unsigned char hi = getbyte(p);
   return hi << 8 | getbyte(p);
}

unsigned int getword(char** p) {
   unsigned short hi = gethalfword(p);
   return hi << 16 | gethalfword(p);
}

int isValidField(int field) {
   return (field>=0x8000 && field<0x9000) || (field>=0x0200 && field<0x0400);
}

unsigned int getSize(unsigned int size,char** pp) {
   size = size & 0x000F;
   if (size == 0x0D)      size = getbyte(pp);
   else if (size == 0x0E) size = gethalfword(pp);
   else if (size == 0x0F) size = getword(pp);
   return size;
}

int getFieldData(char* buf, int cfield, int num, int dsize, char** pptr, char** fptr)
{   char* p = buf;
   unsigned int size=0;
   int inum=0;
   char* cfptr;
   while (p-buf<dsize) {
      cfptr=p;
      unsigned short field = gethalfword(&p);
      if(p-buf>dsize) break;
      size = field & 0x000F;
      field &= 0xFFF0;
      if (size == 0x0D)      size = getbyte(&p);
      else if (size == 0x0E) size = gethalfword(&p);
      else if (size == 0x0F) size = getword(&p);
      if (field == cfield) {
         inum++;
         if(!num || inum==num)
         {
            if(pptr) *pptr=p;
            if(fptr) *fptr=cfptr;
            return (p-buf+size<=dsize)?size:0;
         }
      } else if(!isValidField(field)) {
         break;
      }
      p+=size;
   }
   return 0;
}

int getFieldDataSize(char* buf, int cfield, int num, int dsize)
{   return getFieldData(buf,cfield,num,dsize,0,0);
}

char* getFieldDataPtr(char* buf, int cfield, int num, int dsize)
{   char* ptr=0;
   getFieldData(buf,cfield,num,dsize,&ptr,0);
   return ptr;
}

void copyFieldData(char* buf, int cfield, int num, int dsize, char* outbuf, int bufsize) {
   unsigned int size=getFieldDataSize(buf,cfield,num,dsize);
   if(size>0) {
      char* data=getFieldDataPtr(buf,cfield,num,dsize);
      if(size>bufsize) size=bufsize;
      memcpy(outbuf,data,size);
   }
}

int getTotalFieldsSize(char* buf, int dsize) {
   char* p = buf;
   char* lastp = p;
   while (p-buf<dsize) {
      unsigned short field = gethalfword(&p);
      unsigned short cfield = field & 0xFFF0;
      if((field!=0xFFF0 && !isValidField(field)) || (cfield==0x8000 && p-buf>2)) {
         p-=2;
         break;
      }
      if(p-buf>dsize) return 0;
      unsigned int size=getSize(field,&p);
      p+=size;
      lastp=p;
      if(p-buf>dsize) return 0;
      if(cfield==0xFFF0)
         break;
   }
   return lastp-buf;
}

#define DATE_SIZE 8
#define NZONES  5
#define NMODELS 6
#define NUPDS   5
#define IHX_PAGELINE_SIZE   7
#define IHX_INTERLINE_SIZE   5
#define IHX_DATALINE_HEADSIZE   4
#define IHX_DATA_SIZE   32
#define IHX_DATALINE_SIZE   (IHX_DATALINE_HEADSIZE+IHX_DATA_SIZE+1)
uint8_t imodel_id[NMODELS]      ={2,      4,            0xA,         0xB,            0x1B,         0xF};
char* imodel_name[NMODELS]      ={"TI-73",   "TI-83 Plus",   "TI-84 Plus",   "TI-82 Advanced",   "TI-84 Plus T",   "TI-84 Plus C Silver Edition"};
uint8_t imodel_upd[NMODELS]    ={0,      0,            1,            2,               3,            4};
uint8_t imodel_hwrev[NMODELS]   ={0,      1,            3,            3,               3,            5};
uint8_t imodel_type[NMODELS]   ={0x74,      0x73,         0x73,         0x73,            0x73,         0x73};
uint8_t imodel_irom_minpgsize[NMODELS]={0,   0,            0,            1,               2,            3};
uint8_t imodel_irom_maxpgsize[NMODELS]={2,   2,            2,            1,               2,            3};
uint8_t imodel_irom_defpgsize[NMODELS]={0,   0,            1,            1,               2,            3};

#define NROMS   4
#define PAGE_SIZE 0x4000
#define MAXPAGES 0x100   // 4MB
#define VALID_OFFSET   0x56
uint32_t irom_pgsize[NROMS]={MAXPAGES/8, MAXPAGES/4, MAXPAGES/2, MAXPAGES};

char* izone_name[NZONES]={"OS part #1",   "Applications",   "Signature #2 (2048-bits)", "OS part #2", "Signature #1 (512-bits)"};
//   OS1   endapp    sig2   OS2      sig1
uint32_t irom_izone_pgoffset[NROMS][NZONES]={
   {0,   0x16,   -1,      0x18,   0x1A},   // 512K
   {0,   0x2A,   0x30,   0x34,   0x3A},   // 1024K
   {0,   0x6A,   0x70,   0x74,   0x7A},   // 2048K
   {0,   0xE4,   0xE4,   0xE8,   0xFA}   // 4096K
};

uint32_t irom_izone_pgsize[NROMS][NZONES]={
   {8,   0x0A,   0,      0x06,   0},   // 512K
   {8,   0x1E,   4,      0x0A,   0},   // 1024K
   {8,   0x5E,   4,      0x0A,   0},   // 2048K
   {8,   0xD7,   4,      0x0D,   0}   // 4096K
};
uint32_t iupd_izone_pgoffset[NUPDS][NZONES]={
   {0,   -1,      -1,      0x18,   -1},   // TI-73 / TI-83 Plus
   {0,   -1,      0x10,   0x14,   -1},   // TI-84 Plus
   {0,   0x2A,   0x30,   0x34,   -1},   // TI-82 Advanced
   {0,   0x6A,   0x70,   0x74,   -1},   // TI-84 Plus T
   {0,   -1,      0xE4,   0xE8,   -1}      // TI-84 Plus C Silver Edition
};
uint32_t iupd_izone_pgsize[NUPDS][NZONES]={
   {8,   0,      0,      0x06,   0},   // TI-73 / TI-83 Plus
   {8,   0,      4,      0x0A,   0},   // TI-84 Plus
   {8,   0x0E,   4,      0x0A,   0},   // TI-82 Advanced
   {8,   0x1E,   4,      0x0A,   0},   // TI-84 Plus T
   {8,   0,      4,      0x0D,   0}   // TI-84 Plus C Silver Edition
};

char rombuffer[MAXPAGES*PAGE_SIZE];
#define BUFFER_SIZE (2*(IHX_DATALINE_SIZE+1)+1)

int main(int argc, char* argv[])
{
   int tromsize=0;
   int i;
   
   FILE* rom;
   FILE* upd;
   uint8_t irom=0;
   uint8_t imodel=0;
   uint8_t idmodel=0;
   
   printf("+---------+\n");
   printf("! xxu2rom !\n");
   printf("+---------+\n");
   printf(" X. Andreani\n\n");
   char* rompath=0;
   char* updpath=0;
   
   for(i=1;i<argc;i++) {
      if(!strcmp(argv[i],"-size "))
         i++;
         if(i<argc)
            tromsize=strtol(argv[i],NULL,10)*1024;
      if(!updpath)
         updpath=argv[i];
      else if(!rompath)
         rompath=argv[i];
      
   }
      
   if( !rompath || !updpath)
   {   printf("ERROR: missing or bad arguments\n");
      printf("Usage: %s source.??u dest.rom [-size]\n", argv[0]);
      printf("-size : target ROM size in KB (valid values : 512, 1024, 2048, 4096)\n");
      return 0;
   }
   
   upd=fopen(updpath,"rb");
   if(!upd)
   {   printf("UPD file open error\n");
      return 0;
   }
   
   memset(rombuffer,0xFF,MAXPAGES*PAGE_SIZE);
   rom=fopen(rompath,"rb");
   if(rom) {
      uint32_t size;
      fseek(rom,0,SEEK_END);
      size=ftell(rom);
      if(!tromsize)
         tromsize=size;
      fseek(rom,0,SEEK_SET);
      fread(rombuffer,1,size,rom);
      fclose(rom);
   }
   while(irom_pgsize[irom]*PAGE_SIZE<tromsize && irom<NROMS-1)
      irom++;
   rom=fopen(rompath,"r+");
   if(!rom)
   {   rom=fopen(rompath,"w+");
      if(!rom) {
         printf("ROM file open error\n");
         fclose(upd);
         return 0;
      }
   }
   fseek(upd,0x4E,SEEK_SET);
   uint8_t updhead[IHX_DATALINE_SIZE];
   uint8_t updhead2[IHX_DATALINE_SIZE];
   memset(updhead2,0xFF,IHX_DATALINE_SIZE);
   char buffer[2*IHX_DATALINE_SIZE+3];
   int8_t curpage=-1;
   uint16_t delta=0;
   while(!feof(upd)) {
      fscanf(upd,":");
      fgets(buffer,BUFFER_SIZE,upd);
      uint8_t n;
      sscanf(buffer,"%02hhX",&n);
      for(i=0;i<n+IHX_DATALINE_HEADSIZE;i++)
         sscanf(buffer+2*i,"%02hhX",&(updhead[i]));
      n=updhead[0];
      uint16_t pgoffs=((updhead[1]&((1<<6)-1))<<8)|updhead[2];
      pgoffs+=delta;
      if(n==2 && !pgoffs) {
         curpage=updhead[IHX_DATALINE_HEADSIZE+1];
         printf("update page %02x",curpage);
         for(i=NZONES-1;i>0;i--)
            if(curpage>=iupd_izone_pgoffset[imodel_upd[imodel]][i])
               break;
         curpage=curpage+irom_izone_pgoffset[irom][i]-iupd_izone_pgoffset[imodel_upd[imodel]][i];
         printf(" -> ROM page %02x\n",curpage);
      }
      else if(curpage<0 && n) {
         uint32_t datasize = IHX_DATALINE_SIZE-IHX_DATALINE_HEADSIZE;
         uint8_t* ptr8000=(uint8_t *)getFieldDataPtr((char *)updhead+IHX_DATALINE_HEADSIZE,0x8000,1,datasize);
         uint8_t* ptr=(uint8_t *)getFieldDataPtr((char *)ptr8000,0x8010,1,datasize);
         idmodel=*ptr;
         imodel=0;
         while(imodel<NMODELS && imodel_id[imodel]!=idmodel)
            imodel++;
         if(imodel>=NMODELS) {
            printf("ERROR: unknown target model\n");
            break;
         }
         printf("Target model :\n"),
         printf("- ID ... \t0x%02X\n",idmodel);
         printf("- name ... \t%s\n",imodel_name[imodel]);
         if(!tromsize)
            irom=imodel_irom_defpgsize[imodel];
         printf("- ROM ... \t%dKB\n",irom_pgsize[irom]*PAGE_SIZE/1024);
         memcpy(updhead2,updhead,IHX_DATALINE_SIZE);
      }
      else if(curpage>=0 && n) {
//         printf("write page %x offset %x = %x\n",curpage,pgoffs,curpage*PAGE_SIZE+pgoffs);
         memcpy(rombuffer+curpage*PAGE_SIZE+pgoffs,updhead+IHX_DATALINE_HEADSIZE,n);
      }
      else if(curpage>0 && !n && !delta) { // RSA 512-bits signature special case
         curpage=irom_izone_pgoffset[irom][NZONES-1];
         printf("update page sig1 -> ROM page %x\n",curpage);
         memcpy(rombuffer+curpage*PAGE_SIZE,updhead2+IHX_DATALINE_HEADSIZE,updhead2[0]);
         delta=0x100-2;
      }
   }
   if(imodel<NMODELS) {
      rombuffer[VALID_OFFSET]=0x5A;
      rombuffer[irom_izone_pgoffset[irom][NZONES-1]*PAGE_SIZE+0x100-2]=0xFF;
      rombuffer[irom_izone_pgoffset[irom][NZONES-1]*PAGE_SIZE+0x100-1]=0xFF;
      fwrite(rombuffer,1,irom_pgsize[irom]*PAGE_SIZE,rom);
   }
   fclose(upd);
   return 0;
}
