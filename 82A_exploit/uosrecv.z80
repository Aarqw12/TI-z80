;UOSRECV - Unsigned OS Receiver
;Brandon Wilson
;04/24/2013
;
;This program copies the boot page(s) into RAM and then patches them
; to execute from there, minus a few security checks
; (*cough* 6-minute 2048-bit RSA check *cough*), then passes
; control to it.
;
;The 84+, 84+SE, and 84+CSE are all supported, all known boot code versions,
; all known OS versions, all known link cable types, all known connectivity
; software.
;Theoretically this can also work on the 83+ and 83+SE, but I haven't
; bothered, nor am I going to -- I doubt TI's ever going to go 2048-bit
; on them.
;
;This has the same effect of holding ON+DEL without an OS. Please be aware
; that also means RAM will reset whether the OS transfer is successful
; or not, so back up your stuff.
;Also, if the transfer fails mid-way, you're going to have to install
; the official TI-OS again so you can run the program and try again.
;
;Once you see the familiar "Waiting...Please install operating system now."
; screen, initiate the transfer on your connected PC or calculator.
;
;Run it like so from the homescreen:
;
;	Asm(prgmUOSRECV
;
;This was built with Brass and binpac8x.
;To build for the 84+CSE, uncomment the below #define.
;I'm aware the code is awful; it's meant to be readable and flexible,
; not super fast.
;
;Questions/Comments/Complaints/etc., brandonlw@gmail.com or brandonw.net.
;
;You can't stop this stuff, TI...why try?
;#define TI84PCSE

#define BOOT0_RAM_PAGE 87h
#define BOOT1_RAM_PAGE 80h

#ifdef TI84PCSE
#define BOOT0_ROM_PAGE 0FFh
#define BOOT1_ROM_PAGE 0FDh
#else
#define BOOT0_ROM_PAGE 7Fh
#define BOOT1_ROM_PAGE 6Fh
#endif

#define JUMP0_START 401Ah
#define JUMP0_END 40D4h
#define JUMP1_START 40E6h
#define JUMP1_END 412Bh

.nolist
#ifdef TI84PCSE
#include "ti84pcse.inc"
#else
#include "ti83plus.inc"
#endif
.list

.org userMem-2
#ifdef TI84PCSE
	.db $EF,$69
#else
	.db $BB,$6D
#endif

#ifndef TI84PCSE
	;If not 84+/84+SE/84+CSE, bail out now
	in a,(2)
	bit 5,a
	jr z,errorReturn
#endif

	;Try finding the jump point -- if we can't, bail out now
	di
	in a,(6)
	push af
	in a,(0Eh)
	push af
	ld a,BOOT0_ROM_PAGE
	call outputPage
	ld ix,jumpPointPattern
	ld de,4000h
	call FindPattern
	pop bc
	ld a,b
	out (0Eh),a
	pop bc
	ld a,b
	out (6),a
	jr z,stillGood
errorReturn:
	bcall(_clrLCDFull)
	bcall(_homeUp)
	ld hl,sError
	bcall(_PutS)
	ret
stillGood:
	ld hl,(iMathPtr4)
	ld (iMathPtr5),hl

	;Display unlocking message
	bcall(_clrLCDFull)
	bcall(_homeUp)
	ld hl,sUnlocking
	bcall(_PutS)

	;Unlock Flash and disable RAM execution protection using exploit
	call UnlockFlash
	xor a
	out (25h),a
	dec a
	out (26h),a

	;Display preparing message
	bcall(_clrLCDFull)
	bcall(_homeUp)
	ld hl,sPreparing
	bcall(_PutS)

	;Copy the first boot page to RAM
	di
	ld a,BOOT0_ROM_PAGE
	call outputPage
	ld a,BOOT0_RAM_PAGE & 7Fh
	out (5),a
	ld hl,4000h
	ld de,0C000h
	ld bc,4000h
	ldir

	;Copy the second boot page to RAM
	ld a,BOOT1_ROM_PAGE
	call outputPage
	di
	ld a,BOOT1_RAM_PAGE & 7Fh
	out (5),a
	ld hl,4000h
	ld de,0C000h
	ld bc,4000h
	ldir
	xor a
	out (5),a

#ifndef TI84PCSE
	;Copy replacement USB "zone 1 RAM" routines to
	; the start of the second boot page
	; (which contains 0xFFs, because of the BCALL
	; jump table in the same location on the
	; first boot page)
	ld sp,ramCode
	ld a,BOOT1_RAM_PAGE | 80h
	out (6),a
	call FindEmptyBlock
	ld hl,4000h
	or a
	sbc hl,bc
	ld de,4000h
	add hl,de
	ld ix,USBBufferReadCodeOffset+1
	ld (ix+0),l
	ld (ix+1),h
	ld ix,USBBufferWriteCodeOffset+1
	ld (ix+0),l
	ld (ix+1),h
	ld hl,USBBufferCodeStart
	ld de,4000h
	ld bc,USBBufferCodeEnd-USBBufferCodeStart
	ldir
#endif

	;HACK: This is assuming that the second boot page still has
	; enough room at the end for the hardware stack
	; (which is the case on every version I've ever seen)
	ld sp,0FFFFh

	;Patch the boot page BCALL jump table
	ld a,BOOT0_RAM_PAGE | 80h
	out (6),a
	call FixJumpTableEntries

	;Apply patches to first boot page
	call ApplyPatches

	;Apply patches to second boot page
	ld a,BOOT1_RAM_PAGE | 80h
	out (6),a
	call ApplyPatches

#ifndef TI84PCSE
	;Patch the USB "zone 1 RAM" routines to use the
	; empty space towards the end of the boot page
	; (between end of code and hardware stack)
	ld ix,bufferReadPattern
	ld de,412Ch ;safe place beyond jump table and replacement routines
	call FindPattern
	jr nz,skipReadPattern
#define USBBufferReadCodeLocation USBBufferReadCode-USBBufferCodeStart+4000h
	ld hl,(iMathPtr4)
	ld (hl),0C3h
	inc hl
	ld (hl),USBBufferReadCodeLocation & 0FFh
	inc hl
	ld (hl),USBBufferReadCodeLocation >> 8
skipReadPattern:
	ld ix,bufferWritePattern
	ld de,412Ch ;safe place beyond jump table and replacement routines
	call FindPattern
	jr nz,skipWritePattern
#define USBBufferWriteCodeLocation USBBufferWriteCode-USBBufferCodeStart+4000h
	ld hl,(iMathPtr4)
	ld (hl),0C3h
	inc hl
	ld (hl),USBBufferWriteCodeLocation & 0FFh
	inc hl
	ld (hl),USBBufferWriteCodeLocation >> 8
skipWritePattern:
#endif

	;Jump into the boot code for receiving the OS
	ld a,BOOT0_RAM_PAGE | 80h
	out (6),a
	ld hl,(iMathPtr5)
	ld de,jumpPointPatternEnd-jumpPointPattern
	add hl,de
	di
	jp (hl)

bufferReadPattern:
	xor a
	out (0Fh),a
	ld a,b
	sla a
	out (5),a
	inc a
	or 80h
	out (7),a
	ld b,(hl)
	.db 0FFh
bufferWritePattern:
	xor a
	out (0Fh),a
	ld a,b
	pop bc
	sla a
	out (5),a
	inc a
	or 80h
	out (7),a
	ld a,b
	ld (de),a
	.db 0FFh
USBBufferCodeStart:
USBBufferReadCode:
	push hl
	push de
USBBufferReadCodeOffset:
	ld de,0
	add hl,de
	ld a,(hl)
	pop de
	pop hl
	ret
USBBufferWriteCode:
	pop bc
	push hl
	push de
USBBufferWriteCodeOffset:
	ld hl,0
	add hl,de
	ex de,hl
	ld a,b
	ld (de),a
	pop de
	pop hl
	ret
USBBufferCodeEnd:
	.echo "USB buffer replacement code: "
	.echo USBBufferCodeEnd-USBBufferCodeStart
	.echo " bytes (must be less than ~256 bytes)\n"

sError:
	.db "Error!",0
sUnlocking:
	.db "Unlocking Flash",0CEh,0
sPreparing:
#ifdef TI84PCSE
	.db "Preparing to receive OS",0CEh,0
#else
	.db "Preparing to    "
	.db "receive OS",0CEh,0
#endif
;We'll want to jump just beyond here (past the valid OS check)
;  and start receiving the OS.
jumpPointPattern:
	ld hl,(0056h)
	ld bc,0A55Ah
	or a
	sbc hl,bc
	jp z,0053h
jumpPointPatternEnd:
	.db 0FFh
PatchTable:
	.db OldCode1End-OldCode1Start
	.dw OldCode1Start
	.dw NewCode1
	.db OldCode2End-OldCode2Start
	.dw OldCode2Start
	.dw NewCode2
	.db OldCode3End-OldCode3Start
	.dw OldCode3Start
	.dw NewCode3
	.db OldCode4End-OldCode4Start
	.dw OldCode4Start
	.dw NewCode4
	.db OldCode5End-OldCode5Start
	.dw OldCode5Start
	.dw NewCode5
	.db OldCode6End-OldCode6Start
	.dw OldCode6Start
	.dw NewCode6
	.db OldCode7End-OldCode7Start
	.dw OldCode7Start
	.dw NewCode7
	.db OldCode8End-OldCode8Start
	.dw OldCode8Start
	.dw NewCode8
	.db OldCode9End-OldCode9Start
	.dw OldCode9Start
	.dw NewCode9
	.db OldCode10End-OldCode10Start
	.dw OldCode10Start
	.dw NewCode10
	.db OldCode11End-OldCode11Start
	.dw OldCode11Start
	.dw NewCode11
	.db OldCode12End-OldCode12Start
	.dw OldCode12Start
	.dw NewCode12
	.db OldCode13End-OldCode13Start
	.dw OldCode13Start
	.dw NewCode13
	.db OldCode14End-OldCode14Start
	.dw OldCode14Start
	.dw NewCode14
	.db OldCode15End-OldCode15Start
	.dw OldCode15Start
	.dw NewCode15
	.db 0
;Remove the security checks to ensure we're running on a boot page (non-84+ only).
OldCode1Start:
	in a,(6)
	and 7Fh
	cp 7Fh
OldCode1End:
	.db 0FFh
NewCode1:
	in a,(6)
	xor a \ nop
	nop \ nop
;Remove the security checks to ensure we're running on a boot page (84+ only).
;This can't be merged with the above patch without modifying the FindPattern
; routine to use something other than 0FEh as a wildcard (since that's the "cp" opcode).
OldCode11Start:
	in a,(6)
	and 3Fh
	cp 3Fh
OldCode11End:
	.db 0FFh
NewCode11:
	in a,(6)
	xor a \ nop
	nop \ nop
;Patch the code that swaps in the first boot page.
OldCode2Start:
	ld a,BOOT0_ROM_PAGE & 7Fh
	out (6),a
OldCode2End:
	.db 0FFh
NewCode2:
	ld a,BOOT0_RAM_PAGE | 80h
	out (6),a
;Patch the code that swaps in the second boot page.
OldCode3Start:
	ld a,BOOT1_ROM_PAGE & 7Fh
	out (6),a
OldCode3End:
	.db 0FFh
NewCode3:
	ld a,BOOT1_RAM_PAGE | 80h
	out (6),a
;Patch out the BCALL/BJUMP code that assumes we're swapping in a Flash page.
OldCode4Start:
	ld a,(de)
	ld (hl),a
	inc de
	ld a,(de)
	and 0FEh
	pop de
	pop bc
OldCode4End:
	.db 0FFh
NewCode4:
	ld a,(de)
	ld (hl),a
	inc de
	ld a,(de)
	nop \ nop
	pop de
	pop bc
;Remove the writes to port 14h, in case the RAM pages have the ability to lock Flash back.
;I don't think they can, but you never know.
OldCode5Start:
	out (14h),a
OldCode5End:
	.db 0FFh
NewCode5:
	nop \ nop
;Patch the second boot page's ability to return to the first so it works correctly (non-84+ only).
OldCode6Start:
	ld a,7Fh
	jp 40D5h
OldCode6End:
	.db 0FFh
NewCode6:
	ld a,BOOT0_RAM_PAGE | 80h
	jp 40D5h
;Patch the second boot page's ability to return to the first so it works correectly (84+ only).
;This can probably be merged with the above patch.
OldCode10Start:
	ld a,3Fh
	jp 40D5h
OldCode10End:
	.db 0FFh
NewCode10:
	ld a,BOOT0_RAM_PAGE | 80h
	jp 40D5h
;Remove the stupid 6-7 minute 2048-bit RSA security check.
OldCode7Start:
	call 0FEFEh
	ret nz
	call 0FEFEh
	ld hl,4000h
	ld de,8000h
	ld bc,100h
	ld a,0FAh
OldCode7End:
	.db 0FFh
NewCode7:
	xor a
	ret
;Reset the hardware stack to the highest possible value (we need all we can get).
OldCode8Start:
	ld sp,0FFC5h
OldCode8End:
	.db 0FFh
NewCode8:
	ld sp,0FFFFh
;Only wipe out RAM page 81h (system RAM), because we need the last page for the second boot page.
OldCode9Start:
	ld hl,8000h
	ld de,8001h
	ld bc,0FEFEh
	ld (hl),0
	ldir
OldCode9End:
	.db 0FFh
NewCode9:
	ld hl,8000h
	ld de,8001h
	ld bc,3FFFh
	ld (hl),0
	ldir
;Remove any "oh noes, h4x0rz, must reset" checks (not strictly necessary, but annoying).
OldCode12Start:
	jp z,0000h
OldCode12End:
	.db 0FFh
NewCode12:
	nop \ nop \ nop
;Remove any "oh noes, h4x0rz, must reset" checks (not strictly necessary, but annoying).
OldCode13Start:
	jp nz,0000h
OldCode13End:
	.db 0FFh
NewCode13:
	nop \ nop \ nop
;Remove any masking of the Flash page before writing to port 6.
;I don't think this is really necessary, but it doesn't hurt.
OldCode14Start:
	and 7Fh
	out (6),a
OldCode14End:
	.db 0FFh
NewCode14:
	nop \ nop
	out (6),a
;Modify the boot-page-specific _LoadAIndPaged calls to point to the right page.
;This isn't really necessary since the correct values are also on the real boot page,
; but it doesn't hurt.
OldCode15Start:
	ld a,7Fh
	.db 18h	;jr xx
OldCode15End:
	.db 0FFh
NewCode15:
	ld a,BOOT0_RAM_PAGE | 80h
	.db 18h ;jr xx

ApplyPatches:
	ld ix,PatchTable
applyPatchesLoop:
	ld a,(ix+0)
	or a
	ret z
	ld de,4000h
doPatch:
	ld l,(ix+1)
	ld h,(ix+2)
	push ix
	push hl
	pop ix
	call FindPattern
	pop ix
	jr nz,continueNextPatch
	;We have a match; get its location
	ld de,(iMathPtr4)
	;Get the new code pointer and size
	ld l,(ix+3)
	ld h,(ix+4)
	ld c,(ix+0)
	ld b,0
	;Copy it
	ldir
	;DE points to next potential match
	jr doPatch
continueNextPatch:
	ld bc,5
	add ix,bc
	jr applyPatchesLoop

FixJumpTableEntries:
	ld hl,JUMP0_START
	ld b,(JUMP0_END-JUMP0_START)/3
	call fjte_1
	ld hl,JUMP1_START
	ld b,(JUMP1_END-JUMP1_START)/3
fjte_1:
	ld a,(hl)
	and 3Fh
	cp BOOT0_ROM_PAGE & 3Fh
	jr nz,fjteNot0
	ld a,BOOT0_RAM_PAGE
	ld (hl),a
fjteNot0:
	ld a,(hl)
	and 3Fh
	cp BOOT1_ROM_PAGE & 3Fh
	jr nz,fjteNot1
	ld a,BOOT1_RAM_PAGE
	ld (hl),a
fjteNot1:
	inc hl
	inc hl
	inc hl
	djnz fjte_1
dummyRet:
	ret

outputPage:
	bit 7,a
	res 7,a
	ld b,a
	ld a,1
	jr nz,opBig
	dec a
opBig:
	out (0Eh),a
	ld a,b
	call translatePage
	out (6),a
	ret
translatePage:
	ld b,a
	in a,(2)
	and 80h
	jr z,_is83P
	in a,(21h)
	and 3
	ld a,b
	ret nz
	and 3Fh
	ret
_is83P:
	ld a,b
	and 1Fh
	ret

FindEmptyBlock:
;Returns location in DE
;Returns size in BC
;Returns carry flag set if not found at all
	ld de,8000h
febLoop:
	dec de
	bit 6,d
	scf
	ret z
	ld a,(de)
	inc a
	jr z,febLoop
	inc de
	ld hl,8000h
	or a
	sbc hl,de
	push hl
	pop bc
	ret

FindPattern:
;Pattern in IX, starting address in DE
;Returns NZ if pattern not found
;(iMathPtr4) contains the address of match found
;Search pattern:	terminated by 0FFh
;					0FEh is ? (one-byte wildcard)
;					0FDh is * (multi-byte wildcard)
	ld hl,dummyRet
	push hl
	dec de
searchLoopRestart:
	inc de
	ld (iMathPtr4),de
	push ix
	pop hl
searchLoop:
	ld b,(hl)
	ld a,b
	inc a
	or a
	ret z
	inc de
	inc a
	jr z,matchSoFar
	dec de
	inc a
	ld c,a
	;At this point, we're either the actual byte (match or no match) (C != 0)
	;  or * wildcard (keep going until we find our pattern byte) (C == 0)
	or a
	jr nz,findByte
	inc hl
	ld b,(hl)
findByte:
	ld a,(de)
	inc de
	bit 7,d
	ret nz
	cp b
	jr z,matchSoFar
	;This isn't it; do we start over at the beginning of the pattern,
	;  or do we keep going until we find that byte?
	inc c
	dec c
	jr z,findByte
	ld de,(iMathPtr4)
	jr searchLoopRestart
matchSoFar:
	inc hl
	jr searchLoop

UnlockFlash:
;Unlocks Flash protection.
;Destroys:
;	ramCode
;	iMathPtr4
;This cannot work on the original TI-83 Plus.
;I don't much like this one, but the preferred one doesn't work correctly
; in all emulators.
	di
	in a,(0Eh)
	push af
	in a,(6)
	push af
	ld a,1
	out (0Eh),a
	ld a,7Fh
	out (6),a
	;Find "call ix" code
	ld ix,callIXPattern
	ld de,4000h
	call FindPattern
	jr nz,unlockReturn
	ld hl,(iMathPtr4)
	push hl
	;Find boot page "erase sector 0" reboot code
#ifndef TI84PCSE
	in a,(2)
	bit 5,a
	ld ix,unlockPattern83PSE
	jr z,findPattern1
#endif
	ld ix,unlockPattern
findPattern1:
	ld de,4000h
	call FindPattern
	pop hl
	jr nz,unlockReturn
#ifndef TI84PCSE
	in a,(2)
	bit 5,a
	ld de,unlockPattern83PSECallStart-unlockPattern83PSE
	jr z,foundPattern1
#endif
	ld de,unlockPatternCallStart-unlockPattern
foundPattern1:
	ld ix,(iMathPtr4)
	add ix,de
#ifdef TI84PCSE
	ld h,81h ;H comes from i + flags, L comes from lower byte of return address from boot code
#else
	ld h,80h ;H comes from i + flags, L comes from lower byte of return address from boot code
#endif
	ld (hl),0C3h
	inc hl
	ld (hl),returnPoint & 0FFh
	inc hl
	ld (hl),returnPoint >> 8
	ld a,1
	out (5),a
	ld hl,0
	add hl,sp
	ex de,hl
#ifdef TI84PCSE
	ld sp,8282h+4000h+2+2+2+2-1 ;base comes from boot code "call IX" routine, offsets come from boot code stack trace
#else
	ld sp,82A2h+4000h+2+2+2+2-1 ;base comes from boot code "call IX" routine, offsets come from boot code stack trace
#endif
	ld a,80h
	ld i,a
	jp (ix)
returnPoint:
	ex de,hl
	ld sp,hl
unlockReturn:
	xor a
	out (5),a
	pop af
	out (6),a
	pop af
	out (0Eh),a
unlockRet:
	ret
callIXPattern:
	push bc
	push de
	push hl
	push ix
	pop hl
	ld c,(hl)
	inc hl
	ld b,(hl)
	inc hl
	ld de,ramCode
	push de
	ldir
	pop ix
	pop hl
	pop de
	pop bc
	call 0FEFEh
	push af
	ld a,(82FEh)
	bit 2,a
	.db 0FFh
#ifdef TI84PCSE
unlockPattern:
	call 0FEFEh
	.db 28h,0FEh ;jr z,xx
unlockPatternCallStart:
	push af
	ld a,1
	nop
	nop
	im 1
	di
	out (14h),a
	di
	.db 0FDh
	xor a
	call 0FEFEh
	push af
	xor a
	nop
	nop
	im 1
	di
	out (14h),a
	.db 0FFh
#else
unlockPattern83PSE:
	call 0FEFEh
	.db 28h,0FEh ;jr z,xx
unlockPattern83PSECallStart:
	push af
	ld a,1
	nop
	nop
	im 1
	di
	out (14h),a
	di
	.db 0FDh
	xor a
	call 0FEFEh
	push af
	xor a
	nop
	nop
	im 1
	di
	out (14h),a
	.db 0FFh
unlockPattern:
	ld hl,0FEFEh
	call 0FEFEh
	push af
unlockPatternCallStart:
	ld a,1
	nop
	nop
	im 1
	di
	out (14h),a
	di
	.db 0FDh
	xor a
	push af
	call 0FEFEh
	or a
	.db 28h,0FEh ;jr z,xx
	ld hl,0FEFEh
	push af
	xor a
	nop
	nop
	im 1
	di
	out (14h),a
	.db 0FFh
#endif
.end
end
