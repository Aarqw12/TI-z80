.nolist
#include "../ti83plus.inc"
.list
.org userMem-2
        .db 0BBh,6Dh
; mirageos header
	xor a
	jr    nc,main
title:    .db    "READBOO2",0
main:
        ld hl,sDump
        rst 20h
        bcall(_chkFindSym)
        ret c
        ld a,b
        or a
        ret nz
        push de
        bcall(_runIndicOff)
        bcall(_clrLCDFull)
        bcall(_homeUp)
        ld hl,sConfirm
        bcall(_PutS)
        bcall(_getKey)
        bcall(_runIndicOn)
        bcall(_newLine)
        pop de
        cp kCapY
        ret nz
        inc de
        inc de
        push de
        call UnlockFlash
        ld a,29h
        call translatePage
        ld hl,4000h
        bcall(_EraseFlash)
        ld a,29h
        call translatePage
        ld de,4000h
        ld bc,4000h
        pop hl
        bcall(_WriteFlash) 
        ld hl,sDone
        bcall(_PutS)
        bcall(_newLine)
        ret
sDump:  .db AppVarObj,"D84PBE2",0
sConfirm:
        .db "Press           "
        .db LlBrack,"ALPHA]+",LlBrack,"Y] to  "
        .db "confirm writing "
        .db "or any other key"
        .db "to cancel",0CEh,0
sDone:  .db "2nd boot written",0

outputPage:
	bit 7,a
	res 7,a
	ld b,a
	ld a,1
	jr nz,opBig
	dec a
opBig:
	out (0Eh),a
	ld a,b
	call translatePage
	out (6),a
	ret
translatePage:
	ld b,a
	in a,(2)
	and 80h
	jr z,_is83P
	in a,(21h)
	and 3
	ld a,b
	ret nz
	and 3Fh
	ret
_is83P:
	ld a,b
	and 1Fh
	ret

UnlockFlash:
;Unlocks Flash protection.
	in a,(6)
	push af
	in a,(0Eh)
	push af
	;Find the code to call
;#ifdef TI84PCSE
;	ld a,05h
;#else
	ld a,7Bh
;#endif
	call outputPage
	ld ix,_WriteToFlash
	ld e,(ix+0)
	ld d,(ix+1)
	ld a,(ix+2)
	call outputPage
	ld ix,unlockPattern
	call FindPatternU
	jr nz,unlockReturn
	;Jump into the routine
	set 5,(iy+1Bh)
	xor a
	ld (83A4h),a
	ld (822Fh),a
	ld (83A3h),a
	ld (8672h),a
	inc a
	ld (8432h),a
	ld bc,1
	ld hl,unlockReturn
	push hl
	ld hl,(iMathPtr4)
	push hl
	push hl
	jp (hl)
unlockReturn:
	pop af
	out (0Eh),a
	pop af
	out (6),a
	ret
unlockRet:
	ret
unlockPattern:
	push af
	ld a,1
	nop
	di
	nop
	nop
	im 1
	di
	out (14h),a
	di
	call 0FEFEh
	pop af
	res 6,(iy+24h)
	res 7,(iy+24h)
	xor a
	ld (0FEFEh),a
	push bc
	ld a,(0FEFEh)
	cp 0
	.db 28h,0FEh ;jr z,xx
	ld a,(0FEFEh)
	inc a
	ld (0FEFEh),a
	.db 0CDh ;call...
	.db 0FFh
FindPatternU:
;Pattern in IX, starting address in DE
;Returns NZ if pattern not found
;(iMathPtr4) contains the address of match found
;Search pattern:	terminated by 0FFh
;					0FEh is ? (one-byte wildcard)
;					0FCh is * (multi-byte wildcard)
	ld hl,unlockRet
	push hl
	dec de
searchLoopRestartU:
	inc de
	ld (iMathPtr4),de
	push ix
	pop hl
searchLoopU:
	ld b,(hl)
	ld a,b
	inc a
	or a
	ret z
	inc de
	inc a
	jr z,matchSoFarU
	dec de
	inc a
	inc a
	ld c,a
	;At this point, we're either the actual byte (match or no match) (C != 0)
	;  or * wildcard (keep going until we find our pattern byte) (C == 0)
	or a
	jr nz,findByteU
	inc hl
	ld b,(hl)
findByteU:
	ld a,(de)
	inc de
	bit 7,d
	ret nz
	cp b
	jr z,matchSoFarU
	;This isn't it; do we start over at the beginning of the pattern,
	;  or do we keep going until we find that byte?
	inc c
	dec c
	jr z,findByteU
	ld de,(iMathPtr4)
	jr searchLoopRestartU
matchSoFarU:
	inc hl
	jr searchLoopU

.end
end
