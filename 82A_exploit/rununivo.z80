.include "ti83plus.inc"
.org userMem-2
	.db $BB,$6D
prog_start:
	call UnlockFlash
	ld  hl, Appname
	ld de,progToEdit
	ld bc,8
	ldir
	bcall(_ExecuteApp)
	ret ; this leaks ram I don't care
Appname:
	.db "UnivOS  "
UnlockFlash:
;Unlocks Flash protection.
	in a,(6)
	push af
	in a,(0Eh)
	push af
	;Find the code to call
;#ifdef TI84PCSE
;	ld a,05h
;#else
	ld a,7Bh
;#endif
	call outputPage
	ld ix,_WriteToFlash
	ld e,(ix+0)
	ld d,(ix+1)
	ld a,(ix+2)
	call outputPage
	ld ix,unlockPattern
	call FindPattern
	jr nz,unlockReturn
	;Jump into the routine
	set 5,(iy+1Bh)
	xor a
	ld (83A4h),a
	ld (822Fh),a
	ld (83A3h),a
	ld (8672h),a
	inc a
	ld (8432h),a
	ld bc,1
	ld hl,unlockReturn
	push hl
	ld hl,(iMathPtr4)
	push hl
	push hl
	jp (hl)
unlockReturn:
	pop af
	out (0Eh),a
	pop af
	out (6),a
	ret
unlockRet:
	ret
outputPage:
	bit 7,a
	res 7,a
	ld b,a
	ld a,1
	jr nz,opBig
	dec a
opBig:
	out (0Eh),a
	ld a,b
	call translatePage
	out (6),a
	ret
translatePage:
	ld b,a
	in a,(2)
	and 80h
	jr z,_is83P
	in a,(21h)
	and 3
	ld a,b
	ret nz
	and 3Fh
	ret
_is83P:
	ld a,b
	and 1Fh
	ret
unlockPattern:
	push af
	ld a,1
	nop
	di
	nop
	nop
	im 1
	di
	out (14h),a
	di
	call 0FEFEh
	pop af
	res 6,(iy+24h)
	res 7,(iy+24h)
	xor a
	ld (0FEFEh),a
	push bc
	ld a,(0FEFEh)
	cp 0
	.db 28h,0FEh ;jr z,xx
	ld a,(0FEFEh)
	inc a
	ld (0FEFEh),a
	.db 0CDh ;call...
	.db 0FFh
FindPattern:
;Pattern in IX, starting address in DE
;Returns NZ if pattern not found
;(iMathPtr4) contains the address of match found
;Search pattern:	terminated by 0FFh
;					0FEh is ? (one-byte wildcard)
;					0FCh is * (multi-byte wildcard)
	ld hl,unlockRet
	push hl
	dec de
searchLoopRestart:
	inc de
	ld (iMathPtr4),de
	push ix
	pop hl
searchLoop:
	ld b,(hl)
	ld a,b
	inc a
	or a
	ret z
	inc de
	inc a
	jr z,matchSoFar
	dec de
	inc a
	inc a
	ld c,a
	;At this point, we're either the actual byte (match or no match) (C != 0)
	;  or * wildcard (keep going until we find our pattern byte) (C == 0)
	or a
	jr nz,findByte
	inc hl
	ld b,(hl)
findByte:
	ld a,(de)
	inc de
	bit 7,d
	ret nz
	cp b
	jr z,matchSoFar
	;This isn't it; do we start over at the beginning of the pattern,
	;  or do we keep going until we find that byte?
	inc c
	dec c
	jr z,findByte
	ld de,(iMathPtr4)
	jr searchLoopRestart
matchSoFar:
	inc hl
	jr searchLoop
prog_end:
.fill 2000-(prog_end-prog_start), $FF ;wtf workaround
.end
end
